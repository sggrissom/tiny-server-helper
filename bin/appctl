#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<EOF
Usage:
  appctl init <app_name> <port>
  appctl status
  appctl logs <app_name>
  appctl rollback <app_name>
  appctl domain <app_name> <domain>

Examples:
  sudo appctl init new-site 4100
  appctl status
  appctl logs new-site
  sudo appctl rollback new-site
  sudo appctl domain new-site new-site.com
EOF
}

die() { echo "Error: $*" >&2; exit 1; }

cmd="${1:-}"
[[ -n "${cmd}" ]] || { usage; exit 1; }

case "$cmd" in
  init)
    app="${2:-}"
    port="${3:-}"

    [[ -n "$app" ]]  || die "missing <app_name>"
    [[ -n "$port" ]] || die "missing <port>"
    [[ "$port" =~ ^[0-9]+$ ]] || die "port must be a number"
    (( port >= 1 && port <= 65535 )) || die "port out of range"

    root="/srv/apps/$app"
    rel="$root/releases"
    shared="$root/shared"
    current="$root/current"

    echo "Creating directories for $app..."
    mkdir -p "$rel" "$shared"
    chown -R apps:apps "/srv/apps/$app"

    # Create env file if it doesn't exist
    envfile="$shared/.env"
    if [[ -f "$envfile" ]]; then
      echo "Env already exists: $envfile (leaving as-is)"
    else
      echo "Writing $envfile..."
      cat >"$envfile" <<EOF
PORT=$port
# Add more config here later:
# BASE_URL=https://example.com
# DATABASE_URL=...
EOF
      chmod 600 "$envfile"
    fi

    echo "✅ Init complete:"
    echo "  $root/"
    echo "    releases/"
    echo "    shared/.env"

    echo "Next: deploy a binary (creates current symlink automatically)."
    echo "To start: sudo systemctl enable --now app@$app"
    ;;

  status)
    apps_dir="/srv/apps"
    [[ -d "$apps_dir" ]] || die "/srv/apps does not exist"

    for app_path in "$apps_dir"/*/; do
      [[ -d "$app_path" ]] || continue
      app="$(basename "$app_path")"

      # Get current release
      current="$app_path/current"
      if [[ -L "$current" ]]; then
        release="$(basename "$(readlink "$current")")"
      elif [[ -d "$current" ]]; then
        release="(no release)"
      else
        release="(not initialized)"
      fi

      # Get systemd status
      if systemctl is-active --quiet "app@$app" 2>/dev/null; then
        status="running"
      else
        status="stopped"
      fi

      printf "%-20s %-10s %s\n" "$app" "$status" "$release"
    done
    ;;

  logs)
    app="${2:-}"
    [[ -n "$app" ]] || die "missing <app_name>"
    exec journalctl -u "app@$app" -f
    ;;

  rollback)
    app="${2:-}"
    [[ -n "$app" ]] || die "missing <app_name>"

    root="/srv/apps/$app"
    releases_dir="$root/releases"
    current="$root/current"

    [[ -d "$releases_dir" ]] || die "no releases directory for $app"
    [[ -L "$current" ]] || die "current is not a symlink - nothing to rollback to"

    current_release="$(basename "$(readlink "$current")")"

    # Get sorted releases (newest last), find the one before current
    prev_release=""
    while IFS= read -r rel; do
      [[ "$rel" == "$current_release" ]] && break
      prev_release="$rel"
    done < <(ls -1 "$releases_dir" | sort)

    [[ -n "$prev_release" ]] || die "no previous release to rollback to"

    echo "Rolling back $app: $current_release -> $prev_release"

    ln -sfn "$releases_dir/$prev_release" "$current"
    systemctl restart "app@$app"

    echo "Rollback complete. Now running: $prev_release"
    ;;

  domain)
    # Configure Caddy reverse proxy for an app
    # Reads PORT from app's .env file and creates Caddy config
    app="${2:-}"
    domain="${3:-}"

    [[ -n "$app" ]] || die "missing <app_name>"
    [[ -n "$domain" ]] || die "missing <domain>"

    root="/srv/apps/$app"
    envfile="$root/shared/.env"
    caddy_config="/etc/caddy/sites/$app.caddy"

    # Validate app exists
    [[ -d "$root" ]] || die "app '$app' not found in /srv/apps/"

    # Validate domain format (basic check)
    [[ "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]] || die "invalid domain format: $domain"

    # Extract PORT from .env
    [[ -f "$envfile" ]] || die ".env file not found: $envfile"
    port=$(grep -E "^PORT=" "$envfile" | cut -d= -f2)
    [[ -n "$port" ]] || die "PORT not found in $envfile"
    [[ "$port" =~ ^[0-9]+$ ]] || die "PORT must be numeric, got: $port"
    (( port >= 1 && port <= 65535 )) || die "PORT out of range: $port"

    echo "Configuring Caddy for $app..."
    echo "  Domain: $domain"
    echo "  Port: $port"

    # Create Caddy config (atomic write via temp file)
    temp_config=$(mktemp)
    cat >"$temp_config" <<EOF
$domain {
    reverse_proxy localhost:$port
}
EOF

    # Validate Caddy is installed
    if ! command -v caddy >/dev/null 2>&1; then
      echo "Warning: caddy not installed. Config created but not validated."
      mv "$temp_config" "$caddy_config"
      chmod 644 "$caddy_config"
      echo "✅ Config written to: $caddy_config"
      echo "Install caddy and run: sudo systemctl reload caddy"
      exit 0
    fi

    # Move config into place
    mv "$temp_config" "$caddy_config"
    chmod 644 "$caddy_config"

    # Validate Caddy config
    echo "Validating Caddy config..."
    if ! caddy validate --config /etc/caddy/Caddyfile 2>&1; then
      echo "Error: Caddy config validation failed"
      echo "Config created at $caddy_config but Caddy not reloaded"
      exit 1
    fi

    # Reload Caddy
    echo "Reloading Caddy..."
    if systemctl reload caddy 2>&1; then
      echo "✅ Domain configured successfully"
      echo "   $domain → localhost:$port"
      echo ""
      echo "Next steps:"
      echo "  1. Ensure DNS points to this server"
      echo "  2. Caddy will automatically provision SSL certificate"
      echo "  3. Test: curl https://$domain/healthz"
    else
      echo "Warning: Caddy reload failed. Check: sudo systemctl status caddy"
      exit 1
    fi
    ;;

  *)
    usage
    exit 1
    ;;
esac

